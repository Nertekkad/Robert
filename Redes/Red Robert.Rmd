---
title: "muxViz multigraph"
author: "Víctor LV"
date: "25/7/2021"
output: html_document
---
Se cargan los datos y se extraen los datos de los taxones y los otus almacenados en objeto ps2.
```{r}
library(igraph)
setwd("C:/Users/LaV_V/Downloads")
print(load("mis_phyloseq.RData"))
T_table<-as.data.frame(tax_table(ps2)); dim(T_table)
O_table<-as.data.frame(t(otu_table(ps2))); dim(O_table)
```
Se carga la función T_Collapse
```{r}
#source("me falta guardarlo en un documento aparte")
T_collapse<-function(T_table, O_table, names_level){
  #Identifica los taxones y genera una matriz de columnas vacías
  unq<-unique(T_table[,names_level]); unq
  mat <- matrix(, nrow = length(O_table), ncol = 0)
  #Fusiona los otus que pertenezcan al mismo taxón
  for(i in 1:length(unq)){
    a<-which(T_table[,names_level] %in% unq[i]); a
    b<-as.matrix(colSums(O_table[a,]))
    mat<-cbind(mat, b)
  }
  #Asigna los nombres a las columnas de la matriz resultante
  colnames(mat)<-unq
  #La matriz se transforma a valores relativos de las muestras
  #mat<-mat/rowSums(mat)
  return(print(mat))
}
```
Se ingresa primero la tabla de tacones, luego la tabla de otus y finalmente el nivel taxonómico al cual se desea sintetizar la tabla.
```{r}
T_Collapsed<-T_collapse(T_table = T_table, O_table = O_table,
                        names_level = "Genus")
dim(T_Collapsed)
```
Se identifican los elementos no clasificados para ser eliminados.
```{r}
colnames(T_Collapsed)
T_Collapsed<-T_Collapsed[, -c(which(colnames(T_Collapsed) == "unclassified"))]
                 #Activar en caso de trabajar a nivel de "Family"
                 #which(colnames(T_Collapsed) == "JG30-KF-CM45"),
                 #which(colnames(T_Collapsed) == "67-14"),
                 #which(colnames(T_Collapsed) == "AKIW781"))]
colnames(T_Collapsed)
```
Se identifican los elementos pertenecientes a la planta y al insecto.
```{r}
Insect<-which(sample_data(ps2)$Type =="Insect")
Insect<-sample_data(ps2)$ID[Insect]; Insect
Plant<-which(sample_data(ps2)$Type =="Plant")
Plant<-sample_data(ps2)$ID[Plant]; Plant
```
Generamos matrices independientes para los datos de la planta y del insecto.
```{r}
Insectmat <- T_Collapsed[Insect,]
Plantmat <- T_Collapsed[Plant,]
```
Construímos la red correspondiente a los datos de abundancias del insecto.
```{r}
library(SpiecEasi)
#sparccNet<-sparcc(Insectmat)
#sparccNet <- abs(sparccNet$Cor) >= 0.2
#insect_g<-adj2igraph(sparccNet)

mbNet<-spiec.easi(Insectmat, method = "mb")
insect_g<-adj2igraph(getRefit(mbNet))
vertex.attributes(insect_g) <- list(name = colnames(Insectmat))
plot_network(insect_g)
```
Repetimos el mismo proceso para el caso de la planta.
```{r}
library(SpiecEasi)
#sparccNet<-sparcc(Plantmat)
#sparccNet <- abs(sparccNet$Cor) >= 0.2
#plant_g<-adj2igraph(sparccNet)

mbNet<-spiec.easi(Plantmat, method = "mb")
plant_g<-adj2igraph(getRefit(mbNet))
vertex.attributes(plant_g) <- list(name = colnames(Plantmat))
plot_network(plant_g)
```
En la función v_colored() se identifican los elementos únicos del nivel taxonómico de mayor jerarquía y se genera una paleta de colores con un color asociado a cada elemento.En el ciclo for se obtienen los números de identificación asociados a cada uno de los elementos de unq, para posteriormente asignarles un color dentro del grafo.
```{r}
v_colored<-function(g, T_table, g_tax, p_tax, g_colors){
  require(igraph)
  #Identificación de elementos únicos del taxón de mayor jerarquía
  unq<-unique(T_table[,g_tax])
  #Asignación de colores asociados a los elementos de g_tax en el objeto igraph
  for(i in 1:length(unq)){
    IDs<-which(unq[i] == T_table[,g_tax])
    t_names<-unique(T_table[p_tax][IDs,])
    vertex<-which(vertex.attributes(g)$name %in% t_names)
    V(g)[vertex]$color<-g_colors[i]
  }
  return(g)
}
```
El input de la función v_colored() es un objeto igraph, una paleta de colores cuya longitud debe coincidir con el input de g_tax, además de dos categorías taxonómicas, la primera de las cuales tendrá mayor jerarquía que la segunda. Por ejemplo, en caso de que emplearamos la categoría taxonómica de phylum como input en g_tax, p_tax podría ser cualquiera de los niveles taxonómicos inferiores (clase, familia o especie), además de que este debe ser equivalente al mismo input que se empleo previamente en la función T_Collapse().

Nota: Si se desea visualizar mejor con zoom, 
```{r}
unq<-unique(T_table[,"Phylum"])
colors<-rainbow(length(unq))
insect_g<-v_colored(insect_g, T_table, g_tax = "Phylum", p_tax = "Genus",
                    g_colors = colors)
plant_g<-v_colored(plant_g, T_table, g_tax = "Phylum", p_tax = "Genus",
                   g_colors = colors)
plot(insect_g, vertex.color=vertex.attributes(insect_g)$color,
     vertex.size = 15)
legend(x=-2.7, y=-0.3, unq, title = "Insect", pch=21, pt.bg=colors, pt.cex=2, cex=.8,
       bty="n", ncol=1)
#Aplicar este código e inactivar el anterior solo cuando se deseé visualizar
#el gráfico en Zoom,
#legend(x=-2, y=0.3, unq, pch=21, pt.bg=colors, pt.cex=2, cex=.8,
#       bty="n", ncol=1)
plot(plant_g, vertex.color=vertex.attributes(plant_g)$color,
     vertex.size = 10)
legend(x=-2.7, y=-0.3, unq, title = "Plant", pch=21, pt.bg=colors, pt.cex=2, cex=.8,
       bty="n", ncol=1)
#Aplicar este código e inactivar el anterior solo cuando se deseé visualizar
#el gráfico en Zoom,
#legend(x=-2, y=0.3, unq, pch=21, pt.bg=colors, pt.cex=2, cex=.8,
#       bty="n", ncol=1)
```
Construímos el gráfico 3D de una red multicapa multiplex con el paquete muxViz.
```{r}
library(muxViz)
g.list<-list(insect_g, plant_g); g.list
lay <- layoutMultiplex(g.list, layout="fr", ggplot.format=F, box=T)
plot_multiplex3D(g.list, layer.layout=lay,
                 layer.colors=rainbow(length(g.list)),
                 layer.shift.x=0.5, layer.space=2,
                 layer.labels=c("Insect", "Plant"), layer.labels.cex=1.5,
                 node.size.values="auto", node.size.scale=0.6,
                 node.colors=vertex.attributes(insect_g)$color,
                 edge.colors="white",
                 node.colors.aggr=vertex.attributes(insect_g)$color,
                 show.aggregate=T)
```
Esta función nos permite clasificar los nodos en categorías taxonómicas superiores, es decir, que si los nodos representan géneros o familias, esta función permite clasificarlos a niveles superiores tales como Phylum.
```{r}
TaxGroup<-function(g, T_table, g_tax, p_tax){
  require(igraph)
  unq<-unique(T_table[,g_tax])
  for(i in 1:length(unq)){
    IDs<-which(unq[i] == T_table[,g_tax])
    t_names<-unique(T_table[p_tax][IDs,])
    vertex<-which(vertex.attributes(g)$name %in% t_names)
    V(g)[vertex]$Group<-unq[i]
  }
  return(g)
}
insect_g<-TaxGroup(insect_g, T_table, "Phylum", "Genus")
plant_g<-TaxGroup(plant_g, T_table, "Phylum", "Genus")
vertex.attributes(insect_g)$Group[1:12]
```


```{r}
ctr<-function(g.list, ctr_type){
  if(ctr_type == "degree"){
    require(igraph)
    for(i in 1:length(g.list)){
       ctr_max<-which.max(degree(g.list[[i]]))
       ctr<-degree(g.list[[i]])/degree(g.list[[i]])[ctr_max]
       Redpal<-heat.colors(5, alpha=1)
       hl1<-which(ctr > 0 & ctr <= 0.2)
       V(g.list[[i]])[hl1]$hl<-Redpal[5]
       hl2<-which(ctr > 0.2 & ctr <= 0.4)
       V(g.list[[i]])[hl2]$hl<-Redpal[4]
       hl3<-which(ctr > 0.4 & ctr <= 0.6)
       V(g.list[[i]])[hl3]$hl<-Redpal[3]
       hl4<-which(ctr > 0.6 & ctr <= 0.8)
       V(g.list[[i]])[hl4]$hl<-Redpal[2]
       hl5<-which(ctr > 0.8 & ctr <= 1)
       V(g.list[[i]])[hl5]$hl<-Redpal[1]
       vertex.attributes(g.list[[i]])$hl
       }
    }
    if(ctr_type == "betweenness"){
    require(igraph)
    for(i in 1:length(g.list)){
       ctr_max<-which.max(betweenness(g.list[[i]]))
       ctr<-betweenness(g.list[[i]])/betweenness(g.list[[i]])[ctr_max]
       Redpal<-heat.colors(5, alpha=1)
       hl1<-which(ctr > 0 & ctr <= 0.2)
       V(g.list[[i]])[hl1]$hl<-Redpal[5]
       hl2<-which(ctr > 0.2 & ctr <= 0.4)
       V(g.list[[i]])[hl2]$hl<-Redpal[4]
       hl3<-which(ctr > 0.4 & ctr <= 0.6)
       V(g.list[[i]])[hl3]$hl<-Redpal[3]
       hl4<-which(ctr > 0.6 & ctr <= 0.8)
       V(g.list[[i]])[hl4]$hl<-Redpal[2]
       hl5<-which(ctr > 0.8 & ctr <= 1)
       V(g.list[[i]])[hl5]$hl<-Redpal[1]
       vertex.attributes(g.list[[i]])$hl
       }
    }
    if(ctr_type == "closeness"){
    require(igraph)
    for(i in 1:length(g.list)){
       ctr_max<-which.max(closeness(g.list[[i]]))
       ctr<-closeness(g.list[[i]])/closeness(g.list[[i]])[ctr_max]
       Redpal<-heat.colors(5, alpha=1)
       hl1<-which(ctr > 0 & ctr <= 0.2)
       V(g.list[[i]])[hl1]$hl<-Redpal[5]
       hl2<-which(ctr > 0.2 & ctr <= 0.4)
       V(g.list[[i]])[hl2]$hl<-Redpal[4]
       hl3<-which(ctr > 0.4 & ctr <= 0.6)
       V(g.list[[i]])[hl3]$hl<-Redpal[3]
       hl4<-which(ctr > 0.6 & ctr <= 0.8)
       V(g.list[[i]])[hl4]$hl<-Redpal[2]
       hl5<-which(ctr > 0.8 & ctr <= 1)
       V(g.list[[i]])[hl5]$hl<-Redpal[1]
       vertex.attributes(g.list[[i]])$hl
       }
   }
   return(g.list)
}
```
Visualización de redes individuales en función del degree.
```{r}
g.list_d<-ctr(g.list, ctr_type = "degree")
plot(g.list_d[[1]], vertex.color = vertex.attributes(g.list_d[[2]])$hl,
     vertex.size = 15)
title(main = "Insect")
plot(g.list_d[[2]], vertex.color = vertex.attributes(g.list_d[[2]])$hl,
     vertex.size = 15)
title(main = "Plant")
```
Construcción de gráfico de red multiplex 3D para degree.
```{r}
hl1<-as.vector(vertex.attributes(g.list_d[[1]])$hl)
hl2<-as.vector(vertex.attributes(g.list_d[[2]])$hl)
hl_colors<-c(hl1, hl2)
Nodes<-length(V(g.list[[1]]))
Layers<-length(g.list)
node.colors.matrix <- matrix(hl_colors, Nodes, Layers)
lay <- layoutMultiplex(g.list_d, layout="fr", ggplot.format=F, box=T)
plot_multiplex3D(g.list_d, layer.layout=lay,
                 layer.colors=rainbow(length(g.list_d)),
                 layer.shift.x=0.5, layer.space=2,
                 layer.labels=c("Insect", "Plant"), layer.labels.cex=1.5,
                 node.size.values="auto", node.size.scale=0.8,
                 node.colors=node.colors.matrix, edge.colors="#dadada",
                 show.aggregate=F)
```
Construcción de gráfico de red multiplex 3D para betweenness.
```{r}
g.list_bt<-ctr(g.list, ctr_type = "betweenness")
hl1<-as.vector(vertex.attributes(g.list_bt[[1]])$hl)
hl2<-as.vector(vertex.attributes(g.list_bt[[2]])$hl)
hl_colors<-c(hl1, hl2)
node.colors.matrix <- matrix(hl_colors, Nodes, Layers)
lay <- layoutMultiplex(g.list_bt, layout="fr", ggplot.format=F, box=T)
plot_multiplex3D(g.list_bt, layer.layout=lay,
                 layer.colors=rainbow(length(g.list_bt)),
                 layer.shift.x=0.5, layer.space=2,
                 layer.labels=c("Insect", "Plant"), layer.labels.cex=1.5,
                 node.size.values="auto", node.size.scale=0.8,
                 node.colors=node.colors.matrix, edge.colors="#dadada",
                 show.aggregate=F)
```
Construcción de gráfico de red multiplex 3D para closeness.
```{r}
g.list_cl<-ctr(g.list, ctr_type = "closeness")
hl1<-as.vector(vertex.attributes(g.list_cl[[1]])$hl)
hl2<-as.vector(vertex.attributes(g.list_cl[[2]])$hl)
hl_colors<-c(hl1, hl2)
node.colors.matrix <- matrix(hl_colors, Nodes, Layers)
lay <- layoutMultiplex(g.list_cl, layout="fr", ggplot.format=F, box=T)
plot_multiplex3D(g.list_cl, layer.layout=lay,
                 layer.colors=rainbow(length(g.list_cl)),
                 layer.shift.x=0.5, layer.space=2,
                 layer.labels=c("Insect", "Plant"), layer.labels.cex=1.5,
                 node.size.values="auto", node.size.scale=0.8,
                 node.colors=node.colors.matrix, edge.colors="#dadada",
                 show.aggregate=F)
```